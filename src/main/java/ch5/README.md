# 이벤트 루프

## 이벤트 루프
통상적인 이벤트 기반 애플리케이션의 이벤트 처리 방식은 크게 두가지다.
- 이벤트 리스너와 이벤트 처리 스레드에 기반한 방식
    - 대부분의 UI 프레임워크가 사용하는 방법
    - 대부분 단일 스레드로 구현
- 이벤트 큐에 이벤트를 등록하고 이벤트 루프가 이벤트 큐에 접근하여 처리하는 방법
    - 구현이 복잡하지만 프레임워크 사용자의 입장에서는 더 간편하게 사용 가능
    
이벤트 루프가 다중 스레드일 때 이벤트 큐는 여러개의 스레드에서 공유되고, 가장먼저 이벤트 큐에 접근한 스레드가 이벤트를 가져와서 이벤트를 수행한다. 
즉, 이벤트 루프란 이벤트를 실행하기 위한 무한루프 스레드를 지칭한다.

이벤트 루프에서 지원하는 스레드 종류에 따라서 단일 스레드 이벤트 루프와 다중 스레드 이벤트 루프로 나뉘고, 이벤트 루프가 처리한 이벤트의 결과를 돌려주는 방식에 따라서 콜백 패턴과 퓨처 패턴으로 나뉜다. 
네티에서는 위 두가지 패턴을 모두 지원한다.

### 단일 스레드와 다중 스레드 이벤트 루프
단일 스레드 이벤트 루프는 이벤트를 처리하는 스레드가 하나인 상태를 말한다. 구현이 단순하고 예측가능한 동작을 보장한다. 또한 이벤트의 순서를 보장할 수 있다.
하지만 다중 코어 CPU를 효율적으로 사용하지 못하며 이벤트 메서드에 처리 시간이 오래 걸리는 작업이 섞여 있을 때 나중에 들어온 이벤트는 처리까지 더 오랜 시간이 걸린다.
Node JS 같은 단일 스레드를 다중 코어에서 사용할 때 더 효율적으로 사용하려고 인스턴스를 여러개 띄우기도 한다.

다중 스레드 이벤트 루프는 이벤트를 처리하는 스레드가 두 개 이상이다. 구현이 복잡하고, 이벤트 메서드를 병렬로 수행하므로 다중 코어 cpu의 효율이 높아진다.
하지만 여러 스레드가 자원 하나를 공유할 때 발생하는 스레드 경합 상태가 발생하고, 이벤트의 순서와 실행순서가 불일치한다.

다중 스레드로 애플리케이션을 구현하는 이유는 시간이 많이 걸리는 작업을 여러 스레드로 분할 처리하여 전체 처리 시간을 단축시키기 위함이다. 하지만 스레드 갯수를 너무 많이 설정하거나 제한하지 않는 실수를 저지르지 않도록 조심해야한다.

다중 스레드 아키텍처는 효율적으로 자원을 사용한다는 장점도 있지만 컨텍스트 스위칭 비용과 스레드 경합이라는 단점도 존재하기 때문에 부하테스트를 통해 적절한 수치로 스레드 갯수를 설정하는 것이 매우 중요하다.  

## 네티의 이벤트 루프

 앞에서 다중 스레드는 실행 순서가 보장되지 않는다고 했는데, 네티에서는 사실 이벤트 루프의 종류에 상관없이 이벤트 발생 순서에 따른 실행 순서를 보장한다.
 네티는 다중 스레드의 실행 순서 문제를 아래와 같은 특징으로 극복했다.
 - 네티의 이벤트는 채널에서 발생한다.
 - 이벤트 루프 객체는 이벤트 큐를 가지고 있다.
 - 네티의 채널은 하나의 이벤트 루프에 등록된다.
 
 네티의 각 채널은 개별 이벤트 루프 스레드에 등록되므로 채널에서 발생한 이벤트는 항상 동일한 이벤트 루프 스레드에서 처리된다. 즉, 이벤트 큐를 공유하지 않고 각각 사용함으로써 수행 순서 불일치의 원인을 제거했다.
 
 네티는 이벤트 처리를 위해 `SingleThreadEventExecutor`를 사용한다. [링크](https://github.com/carrot-garden/net_netty/blob/master/transport/src/main/java/io/netty/channel/SingleThreadEventExecutor.java) 
 
 ## 네티의 비동기 I/O 처리
 
 네티는 비동기 호출을 위해 리액터 패턴의 구현체인 이벤트 핸들러와 퓨처 패튼을 사용하고 있다.
 
 퓨처 패턴은 미래에 끝날 작업을 등록후 처리 결과를 확인하는 객체를 통해 작업의 완료를 확인하는 패턴이다. 퓨처 패턴은 메서드가 호출되자마자 퓨처 객체를 응답한다. 이 메서드의 실행 결과는 Future 객체를 통해 확인한다.
 
 ```java
    ChannelFuture f = b.bind(PORT).sync();
    f.channel().closeFuture().sync();
```

위의 코드가 Future의 구현체인 ChannelFuture를 사용하는 예이다.

네티에서는 future객체가 작업을 완료했는지 확인하기위해 while루프를 돌리는 것이 비효율적이라고 판단했고, 대신 완료되었을때 수행할 리스너를 설정할 수 있도록 하였다.
 
 ```java
public class EchoServerHandler extends  ChannelInboundHandlerAdapter {   
    @Override
    public void channelRead(ChannelHandlerContext ctx, Object msg){
        ChannelFuture channelFuture = ctx.writeAndFlush(msg); // 
        channelFuture.addListener(ChannelFutureListener.CLOSE);
    }   
} 
```

기존 작성한 이벤트 핸들러와 위의 이벤트 핸들러가 다른 점은 위 코드는 연결된 클라이언트로 데이터 전송이 완료되면 리스너를 통해 연결된 소켓 채널을 닫는다.
이 때 리스너가 바로 future객체를 통해 동작한다.

네티에서는 기본 채널 리스너를 제공하고 있다.

- `ChannelFutureListener.CLOSE` 
- `ChannelFutureListener.CLOSE_ON_FAILURE`
- `ChannelFutureListener.FIRE_EXCEPTION_ON_FAILURE`

ChannelFutureListener 인터페이스의 구현체를 작성하면 네티가 기본 제공하는 리스너보다 더 복잡한 작업을 처리할 수 있다.

