# 바이트 버퍼

네티에서는 자바에서 제공하는 버퍼 패키지말고 자체 버퍼 API를 사용한다.

## 자바 NIO 바이트 버퍼
자바 NIO 바이트 버퍼는 바이트 데이터를 저장하고 읽는 저장소이다. 추상화한 메서드로 개발자가 배열의 인덱스에 대한 추가적인 계산 없이 데이터의 변경 처리를 수행할 수 있다.
 자바에서 제공하는 바이트 버퍼에는 `ByteBuffer`, `CharBuffer`, `IntBuffer`, `ShortBuffer`, `LongBuffer`, `FloatBuffer`, `DoubleBuffer`가 있으며 각 바이트 버퍼는 저장되는 데이터형에 따라 적당한 클래스를 선택해 사용한다.
 바이트 버퍼 클래스의 내부 배열 상태를 관리하는 세가지 속성은 아래와 같다.

 - **capacity**
    - 버퍼에 저장할 수 있는 데이터의 최대 크기로 한 번 정하면 변경이 불가능하다.
 - **position**
    - 읽기 또는 쓰기가 작업 중인 위치를 나타낸다. 버퍼 객체가 생설될 때 0으로 초기화되고 데이터를 입력하는 put이나 읽는 get 메서드가 호출되면 자동으로 증가하며 limit과 capacity 값보다 작거나 같다.
 - **limit** 
    - 읽고 쓸 수 있는 버퍼 공간의 최대치를 나타낸다.

### 자바 바이트 버퍼 생성
자바의 바이트 버퍼는 데이터형에 따른 추상 클래스의 팩토리 메서드를 통해서 생성한다. 생성 메서드는 세가지가 존재한다.

- **allocate**
    - JVM의 힙 영역에 바이트 버퍼를 생성한다. 메서드의 인수는 생성할 바이트 버퍼의 크기이다. 
- **allocateDirect**
    - JVM의 힙 영역이 아닌 운영체제의 커널 영역에 바이트 버퍼를 생성한다. `allocateDirect`는 `ByteBuffer`의 추상클래스만 사용 가능
- **wrap**
    - 입력된 바이트 배열을 사용하여 바이트 버퍼를 생성
    
### 버퍼 사용
예제로 대체

## 네티 바이트 버퍼
네티 바이트 버퍼는 자바 바이트 버퍼보다 빠른 성능을 제공한다.
가비지 컬렉션에 대한 부담 또한 줄여준다. 네티 바이트 버퍼가 가진 특징을 나열하면 다음과 같다.

- 별도의 읽기 인덱스와 쓰기 인덱스 
- flip 메서드 없이 읽기 쓰기 가능
- 가변 바이트 버퍼
- 바이트 버퍼 풀
- 복합 버퍼
- 자바의 바이트 버퍼와 네티의 바이트 버퍼 상호 변환

네티 바이트 버퍼는 각 데이터형에 대한 읽기 쓰기 메서드를 제공한다. 또한 읽기, 쓰기 메서드가 실행될 때 각각 읽기 인덱스와 쓰기 인덱스를 증가시킨다.
네티의 바이트 버퍼는 인덱스가 각각 존재하기 때문에 읽기 작업 완료후에 쓰기 작업을 위해서 flip 메서드를 호출할 필요가 없다.  

### 네티 바이트 버퍼 생성

네티 바이트 버퍼는 프레임워크 레벨의 바이트 버퍼 풀을 제공하여 바이트 버퍼를 재사용한다. 네티의 바이트 버퍼를 바이트 버퍼풀에 할당하려면 `ByteBufAllocator`를 사용한다.
즉 `PooledByteBufAllocator` 로 각 바이트 버퍼를 생성한다.



네티 바이트 버퍼 종류

|               | 풀링 함             | 풀링 안함             |
| ------------- | ------------------- | --------------------- |
| 힙 버퍼       | PooledHeapByteBuf   | UnpooledHeapByteBuf   |
| 다이렉트 버퍼 | PooledDirectByteBuf | UnpooledDirectByteBuf |



네티 바이트 버퍼 생성 방법

|               | 풀링 함                                 | 풀링 안함               |
| ------------- | --------------------------------------- | ----------------------- |
| 힙 버퍼       | ByteBufAllocator.DEFAULT.heapBuffer()   | Unpooled.buffer()       |
| 다이렉트 버퍼 | ByteBufAllocator.DEFAULT.directBuffer() | Unpooled.directBuffer() |



### 버퍼 사용



- 바이트 버퍼 읽기 쓰기
  - 네티 바이트 버퍼는 자바 바이트 버퍼와 달리 `flip` 을 사용하지 않는다.
  - 예제를 통해 알아보자.
- 가변 크기 버퍼
  - 자바 바이트 버퍼는 버퍼 생성시 지정한 크기를 변경할 수 없지만, 네티 바이트 버퍼는 생성된 버퍼의 크기를 동적으로 변경할 수 있다.
  
- 바이트 버퍼 풀링
    - 네티 바이트 버퍼의 가장 중요한 특징.
    - 다이렉트 버퍼와 힙 범퍼 모두 풀링 가능
    - 가바지 컬렉션 횟수가 감소
    - 바이트 버퍼 풀링을 위해 바이트 버퍼에 참조 수를 기록.
    - `ReferenceCountUtil` 클래스에 정의된 retain, release 메소드 사용
 
- 부호 없는 값 읽기
    - 자바는 C언어와 달리 부호 없는 데이터형이 없음
    - 1바이트 데이터를 부호 없는 데이터로 변환하려면 2바이트 데이터형이 필요
    - 네티에서 `getUnsingedXXX` 형으로 `Byte`,`Short`, `Medium`, `Int` 지원

- 엔디안 변환
    - 네티의 바이트 버퍼 기본 엔디안은 자바와 동일한 빅엔디안
    - 하지만 리틀 엔디안의 바이트 버퍼가 필요하다면 order메서드를 사용하여 가능
    
 ```java
    ByteBuf buf = Unpooled.buffer();    //빅엔디안
    ByteBuf littleEndianBuf = buf.order(ByteOrder.LITTLE_ENDIAN);   //리틀엔디안
```

- 바이트 버퍼 상호 변환
    - 네티 바이트 버퍼에서 `nioBuffer`메서드를 활용하여 자바 NIO 바이트 버퍼로 변환이 가능
    - 버퍼의 내용이 서로 공유 됨
    
- 채널과 바이트 버퍼 풀
    - 채널에서 channelRead 메서드가 실행된 이후 네티 바이트 버퍼는 바이트 버퍼 풀로 돌아간다. 네티 바이트 버퍼 풀은 서버 소켓 채널이 초기화될 때 같이 초기화되며 ChannelHandlerContext 인터페이스의 alloc 메서드로 생성된 바이트 버퍼 풀을 참조 가능하다.